library(maxLik)
library(GIGrvg)

rm(list = ls())


loglik.MCPGIGR.inde = function(params, y1, y2, x)
{
  n   = length(y1)
  m   = length(params)
  p   = ncol(x)
  
  # params = (beta1, beta2, xi, tau), length = 2p + 2
  beta1 <- params[1:p]
  beta2 <- params[(p+1):(2*p)]
  xi    <- params[2*p + 1]
  tau   <- params[2*p + 2]
  shape <- -0.5   # fixed
  
  btX1  <- x %*% beta1
  btX2  <- x %*% beta2
  ebtX1 <- exp(btX1)
  ebtX2 <- exp(btX2)
  
  w       = sqrt(tau^2 + xi^2) - xi
  h       = w + 2 * ebtX2
  v       = sqrt(tau^2 + xi^2)
  c12     = (y2 + shape)/2
  shape32 = shape - 1
  shape12 = shape + 1
  
  Kw1  = besselK(w, shape)
  Kw32 = besselK(w, shape32)
  Kw12 = besselK(w, shape12)
  Rw   = Kw12 / Kw1
  
  z   = sqrt(w * (w + 2 * ebtX2))
  c1  = y2 + shape
  c32 = y2 + shape - 1
  c21 = y2 + shape + 1
  K1  = besselK(z, c1)
  K2  = besselK(z, c32)
  K3  = besselK(z, c21)
  
  loglik = numeric(n)
  
  for(i in 1:n) {
    loglik[i] = 
      log( (xi^(-shape)) ) +
      y1[i]*log(ebtX1[i]/xi) - lgamma(y1[i] + 1) +
      (y2[i] - y1[i])*log( abs(ebtX2[i] - ebtX1[i])/(xi*Rw) ) -
      lgamma(y2[i] - y1[i] + 1) +
      c12[i]*log( (w*xi^2)/h[i] ) +
      log(K1[i])
  }
  
  return(loglik)  
}


grad.MCPGIGR.inde = function(params, y1, y2, x)
{
  n   = length(y1)
  m   = length(params)
  p   = ncol(x)
  
  beta1 <- params[1:p]
  beta2 <- params[(p+1):(2*p)]
  xi    <- params[2*p + 1]
  tau   <- params[2*p + 2]
  shape <- -0.5
  
  btX1  <- x %*% beta1
  btX2  <- x %*% beta2
  ebtX1 <- exp(btX1)
  ebtX2 <- exp(btX2)
  
  w       = sqrt(tau^2 + xi^2) - xi
  h       = w + 2 * ebtX2
  v       = sqrt(tau^2 + xi^2)
  c12     = (y2 + shape)/2
  shape32 = shape - 1
  shape12 = shape + 1
  
  Kw1  = besselK(w, shape)
  Kw32 = besselK(w, shape32)
  Kw12 = besselK(w, shape12)
  Rw   = Kw12 / Kw1
  
  z   = sqrt(w * (w + 2 * ebtX2))
  c1  = y2 + shape
  c32 = y2 + shape - 1
  c21 = y2 + shape + 1
  K1  = besselK(z, c1)
  K2  = besselK(z, c32)
  K3  = besselK(z, c21)
  
  g = matrix(0, n, m)   # m = 2p + 2
  
  for (i in 1:n) {
    ## dℓ_i / d beta1
    diff.beta1 = x[i, ] * y1[i] -
      x[i, ] * (y2[i] - y1[i]) * (ebtX1[i] / (ebtX2[i] - ebtX1[i]))
    
    ## dℓ_i / d beta2
    diff.beta2 =
      - x[i, ] * (y2[i] - y1[i]) * (ebtX2[i] / (ebtX2[i] - ebtX1[i])) +
      x[i, ] * ((-K3[i] + (K1[i] * (y2[i] + shape) / z[i])) / K1[i]) *
      ((w * ebtX2[i]) / z[i]) -
      x[i, ] * ((y2[i] + shape)/2) * (ebtX2[i] / h[i])
    
    ## dℓ_i / d xi  (sama seperti versi Anda, hanya disesuaikan indexing)
    diff.xi =
      (((-K3[i] + (K1[i] * (y2[i] + shape) / z[i])) /
          (2 * z[i] * K1[i])) * (((xi/v) + 1)*h[i] + w * ((xi/v) + 1))) -
      ((((shape/w) * Kw1[i] - Kw12[i]) / Kw1[i]) * ((xi/v) + 1)) -
      ((y2[i] + shape) * ((xi/v) + 1) / (2 * h[i]))
    
    ## dℓ_i / d tau
    diff.tau =
      ((-K3[i] + (K1[i] * (y2[i] + shape) / z[i])) *
         tau * (w + h[i]) / (2 * z[i] * v * K1[i])) -
      ((((shape/w) * Kw1[i] - Kw12[i]) / (2 * w * v * Kw1[i])) * tau) +
      ((y2[i] + shape) * tau / (2 * h[i] * v))
    
    g[i, 1:p]         = diff.beta1
    g[i, (p+1):(2*p)] = diff.beta2
    g[i, 2*p + 1]     = diff.xi
    g[i, 2*p + 2]     = diff.tau
  }
  
  g[!is.finite(g)] <- NA
  gmin = min(g, na.rm = TRUE)
  g    = ifelse(is.na(g), gmin, g)
  
  return(g)   # matrix n x m (BHHH)
}

rMPGIG_bivar <- function(X, beta1, beta2, xi, tau, shape) {
  stopifnot(is.matrix(X), ncol(X) == length(beta1), ncol(X) == length(beta2))
  stopifnot(xi > 0, tau > 0)
  
  n <- nrow(X)
  lambda1 <- as.vector(exp(X %*% beta1))  # rates for Z1 (without xi*Lambda)
  lambda2 <- as.vector(exp(X %*% beta2))  # rates for Z2
  
  # GIG parameters
  omega      <- (sqrt(tau^2 + xi^2)) - xi        # > 0
  psi_const  <- omega/xi                           # scalar
  
  # Latent GIG for each i (vectorized over chi_i)
  Lambda <- GIGrvg::rgig(n, lambda = shape, chi = omega, psi = psi_const)
  
  # Components
  Z1 <- rpois(n,Lambda*lambda1)  # include xi as specified in the model
  Z2 <- rpois(n,lambda2)
  
  cbind(y1 = Z1, y2 = Z1 + Z2)
}


sim.mpgigr <- function(params, n = 100, B = 100, 
                       makeX = NULL,
                       write.csv = FALSE,
                       prefix = "MPGIGR")
{
  # params = (beta1, beta2, xi, tau)
  m      <- length(params)
  p      <- (m - 2)/2        
  stopifnot(p == floor(p))
  
  beta1  <- params[1:p]
  beta2  <- params[(p+1):(2*p)]
  xi     <- params[2*p + 1]
  tau    <- params[2*p + 2]
  shape  <- -0.5             # fixed, 
  
  par_names_beta1 <- paste0("beta1_", 0:(p-1))
  par_names_beta2 <- paste0("beta2_", 0:(p-1))
  col_par <- c(par_names_beta1, par_names_beta2, "xi", "tau")
  
  parameter <- matrix(NA, nrow = B, ncol = length(col_par))
  colnames(parameter) <- col_par
  loglik    <- numeric(B)
  AIC  <- rep(NA, B)
  AICc <- rep(NA, B)
  
  cat("Progress simulasi ke: ")
  
  if (is.null(makeX)) {
    makeX <- function(n) {
      if (p == 1) {
        X <- matrix(1, nrow = n, ncol = 1)
        colnames(X) <- "Intercept"
        return(X)
      } else {
        Xcov <- replicate(p-1, runif(n, 0, 10))
        X    <- cbind(Intercept = 1, Xcov)
        colnames(X) <- c("Intercept", paste0("X", 1:(p-1)))
        return(X)
      }
    }
  }
  
  for (j in 1:B) {
    X <- makeX(n)
    Y <- rMPGIG_bivar(X, beta1, beta2, xi, tau, shape)
    y1 <- Y[,1]; y2 <- Y[,2]
    
    # 4.3 Starting values 
    Z2_hat <- pmax(y2 - y1, 0)
    
    df1 <- data.frame(y = y1, X)
    form <- if (p == 1) y ~ 1 else
      as.formula(paste("y ~", paste(colnames(X)[-1], collapse = " + ")))
    
    # --- Beta1 ---
    fit1 <- glm(form, family = poisson, data = df1)
    beta1_start <- coef(fit1)
    beta1_start[!is.finite(beta1_start)] <- 0
    if (length(beta1_start) < p)
      beta1_start <- c(beta1_start, rep(0, p - length(beta1_start)))
    
    # --- Beta2 ---
    df2 <- data.frame(y = Z2_hat, X)
    fit2 <- glm(form, family = poisson, data = df2)
    beta2_start <- coef(fit2)
    beta2_start[!is.finite(beta2_start)] <- 0
    if (length(beta2_start) < p)
      beta2_start <- c(beta2_start, rep(0, p - length(beta2_start)))
    
    xi_start  <- abs(xi)  * runif(1, 0.8, 1.2)
    tau_start <- abs(tau) * runif(1, 0.8, 1.2)
    
    
    start <- c(beta1_start, beta2_start, xi_start, tau_start)
    
    # --- 4.4 Estimasi MLE BHHH 
    est <- try(
      maxBHHH(
        loglik.MCPGIGR.inde,
        grad.MCPGIGR.inde,
        start = start,
        y1    = y1,
        y2    = y2,
        x     = X
      ),
      silent = TRUE
    )
    
    if (inherits(est, "try-error")) {
      parameter[j, ] <- NA
      loglik[j]      <- NA
      AIC[j]         <- NA
      AICc[j]        <- NA
      next
    }
    
    len_est <- length(est$estimate)
    if (len_est != ncol(parameter)) {
      
      parameter[j, ] <- NA
      loglik[j]      <- NA
      AIC[j]         <- NA
      AICc[j]        <- NA
    } else {
      parameter[j, ] <- est$estimate
      loglik[j]      <- est$maximum   # ini ℓ_max (total)
      
      k <- len_est    
      # AIC
      AIC[j]  <- -2 * est$maximum + 2 * k
      if (n > k + 1) {
        AICc[j] <- AIC[j] + (2 * k * (k + 1)) / (n - k - 1)
      } else {
        AICc[j] <- NA   # kalau n terlalu kecil
      }
    }
    
    cat(j, " ")
    
    
  }
  cat("\n")
  #------------------------------------------

  valid_rows <- which(rowSums(is.na(parameter)) < ncol(parameter))
  if (length(valid_rows) == 0) {
    stop("Tidak ada replikasi yang berhasil (semua est$estimate gagal).")
  }
  
  parameter_valid <- parameter[valid_rows, , drop = FALSE]
  
  beta_hat   <- parameter_valid[, 1:(2*p), drop = FALSE]
  beta1_hat  <- beta_hat[, 1:p, drop = FALSE]
  beta2_hat  <- beta_hat[, (p+1):(2*p), drop = FALSE]
  # --- Ringkasan xi dan tau ---
  idx_xi  <- 2*p + 1
  idx_tau <- 2*p + 2
  
  xi_hat  <- parameter_valid[, idx_xi]
  tau_hat <- parameter_valid[, idx_tau]
  
  xi_true  <- xi
  tau_true <- tau
  
  xi_summary <- c(
    True = xi_true,
    Mean = mean(xi_hat, na.rm = TRUE),
    SD   = sd(xi_hat,   na.rm = TRUE)
  )
  
  tau_summary <- c(
    True = tau_true,
    Mean = mean(tau_hat, na.rm = TRUE),
    SD   = sd(tau_hat,   na.rm = TRUE)
  )
  
  # CI 95% untuk xi dan tau
  CI_xi  <- quantile(xi_hat,  probs = c(0.025, 0.975), na.rm = TRUE)
  CI_tau <- quantile(tau_hat, probs = c(0.025, 0.975), na.rm = TRUE)
  
  
  beta_hat   <- parameter[, 1:(2*p), drop = FALSE]
  beta1_hat  <- beta_hat[, 1:p, drop = FALSE]
  beta2_hat  <- beta_hat[, (p+1):(2*p), drop = FALSE]
  beta1_true <- beta1
  beta2_true <- beta2
  
  resum1 <- cbind(
    True = beta1_true,
    Mean = apply(beta1_hat, 2, mean, na.rm = TRUE),
    SD   = apply(beta1_hat, 2, sd,   na.rm = TRUE)
  )
  rownames(resum1) <- par_names_beta1
  
  resum2 <- cbind(
    True = beta2_true,
    Mean = apply(beta2_hat, 2, mean, na.rm = TRUE),
    SD   = apply(beta2_hat, 2, sd,   na.rm = TRUE)
  )
  rownames(resum2) <- par_names_beta2
  
  
  beta_true_vec <- c(beta1_true, beta2_true)
  beta_mean_vec <- apply(beta_hat, 2, mean, na.rm = TRUE)
  
  beta_bias <- sqrt(sum((beta_mean_vec - beta_true_vec)^2))
  beta_var  <- sum(apply(beta_hat, 2, var, na.rm = TRUE))
  
  J <- matrix(1, nrow = nrow(beta_hat), ncol = 1)
  beta_RMSE <- sqrt(mean((beta_hat - J %*% t(beta_true_vec))^2, na.rm = TRUE))
  
  CI_beta <- apply(
    beta_hat, 2,
    quantile,
    probs = c(0.025, 0.975),
    na.rm = TRUE
  )
  
  if (write.csv) {
    write.csv(parameter, paste0(prefix, "_Hasil_Simulasi.csv"), row.names = FALSE)
    write.csv(cbind(resum1, resum2), paste0(prefix, "_Ringkasan_Beta.csv"))
    write.csv(CI_beta, paste0(prefix, "_CI_Beta.csv"))
  }
  
  list(
    parameter     = parameter,
    loglik        = loglik,
    AIC           = AIC,
    AICc          = AICc,
    beta_summary1 = resum1,
    beta_summary2 = resum2,
    beta_bias     = beta_bias,
    beta_var      = beta_var,
    beta_RMSE     = beta_RMSE,
    CI_beta       = CI_beta,
    xi_summary    = xi_summary,
    tau_summary   = tau_summary,
    CI_xi         = CI_xi,
    CI_tau        = CI_tau
  )
  
  
  
}

beta1_true <- c( 1.2, -0.07)
beta2_true <- c( 3.4, -0.06)
xi_true    <- 1.00423
tau_true   <- 0.58769
shape_true <- -0.5   # fixed,

params_true <- c(beta1_true, beta2_true, xi_true, tau_true)

res_mpgigr <- sim.mpgigr(params_true, n = 100, B = 50,
                         makeX = function(n) {
                           X1 <- runif(n, 0, 10)
                           cbind(Intercept = 1, X1 = X1)
                         })
res_mpgigr$beta_summary1
res_mpgigr$beta_summary2
res_mpgigr$beta_bias
res_mpgigr$CI_beta
res_mpgigr$xi_summary
res_mpgigr$tau_summary
res_mpgigr$CI_xi
res_mpgigr$CI_tau
mean(res_mpgigr$AICc, na.rm = TRUE)


